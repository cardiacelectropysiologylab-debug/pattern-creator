import math
import random
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from reportlab.pdfgen import canvas
from reportlab.lib.units import mm
from reportlab.lib import colors
from PIL import Image, ImageDraw, ImageTk

# Common MatTek well diameters (mm)
MATTEK_SIZES = {
    "35mm dish (20mm well)": 20.0,
    "35mm dish (14mm well)": 14.0,
    "35mm dish (10mm well)": 10.0,
    "50mm dish (30mm well)": 30.0,
}

def draw_circle_background(c, diameter_mm):
    """Draw black background with white circle"""
    radius_pt = (diameter_mm / 2.0) * mm
    page_size = diameter_mm * mm + 4 * mm
    cx = cy = page_size / 2.0
    c.setFillColor(colors.black)
    c.rect(0, 0, page_size, page_size, stroke=0, fill=1)
    c.setFillColor(colors.white)
    c.circle(cx, cy, radius_pt, stroke=0, fill=1)
    return page_size, cx, cy, radius_pt

def clip_to_circle(c, cx, cy, radius_pt):
    """Clip drawing to circular region"""
    c.saveState()
    p = c.beginPath()
    p.circle(cx, cy, radius_pt)
    c.clipPath(p, stroke=0, fill=0)

def end_clip(c):
    """End clipping"""
    c.restoreState()

# ========== INTERSTITIAL PATTERN ==========
def add_interstitial(c, cx, cy, radius_pt, coverage, stripe_width_mm, angle_deg=0):
    """Add parallel stripes (interstitial fibrosis)"""
    if coverage <= 0:
        return
    stripe_width_pt = stripe_width_mm * mm
    if coverage >= 1:
        gap_pt = 0
    else:
        gap_pt = stripe_width_pt * (1.0 - coverage) / max(coverage, 1e-6)
    diag = radius_pt * 2 * math.sqrt(2)
    total_width = diag + 4 * (stripe_width_pt + gap_pt)
    x0 = cx - total_width / 2.0
    c.saveState()
    c.translate(cx, cy)
    c.rotate(angle_deg)
    c.translate(-cx, -cy)
    c.setFillColor(colors.black)
    x = x0
    while x < x0 + total_width:
        c.rect(x, cy - diag / 2.0, stripe_width_pt, diag, stroke=0, fill=1)
        x += stripe_width_pt + gap_pt
    c.restoreState()

def add_interstitial_preview(draw, cx, cy, radius_px, coverage, stripe_width_px, angle_deg):
    """Preview for interstitial pattern"""
    temp = Image.new("L", draw.im.size, 255)
    dtemp = ImageDraw.Draw(temp)
    stripe_width_px = max(1.0, stripe_width_px)
    if coverage > 0:
        gap_px = stripe_width_px * (1.0 - coverage) / max(coverage, 1e-6)
    else:
        gap_px = 0
    diag = radius_px * 2 * math.sqrt(2)
    total_width = diag + 4 * (stripe_width_px + gap_px)
    x0 = -total_width / 2.0
    angle = math.radians(angle_deg)
    cos_a = math.cos(angle)
    sin_a = math.sin(angle)
    x = x0
    while x < x0 + total_width:
        xr0, xr1 = x, x + stripe_width_px
        y_low, y_high = -diag / 2.0, diag / 2.0
        corners_r = [(xr0, y_low), (xr1, y_low), (xr1, y_high), (xr0, y_high)]
        pts = [(cx + xr * cos_a - yr * sin_a, cy + xr * sin_a + yr * cos_a) for xr, yr in corners_r]
        dtemp.polygon(pts, fill=0)
        x += stripe_width_px + gap_px
    mask = Image.new("L", draw.im.size, 0)
    dmask = ImageDraw.Draw(mask)
    dmask.ellipse((cx-radius_px, cy-radius_px, cx+radius_px, cy+radius_px), fill=255)
    temp.paste(255, mask=Image.eval(mask, lambda v: 255-v))
    draw.bitmap((0, 0), temp)

# ========== DIFFUSE PATTERN ==========
def add_diffuse(c, cx, cy, radius_pt, coverage, spot_size_mm, density):
    """Add randomly distributed small spots (diffuse fibrosis)"""
    if coverage <= 0:
        return
    spot_radius_pt = (spot_size_mm / 2.0) * mm
    area_total = math.pi * radius_pt ** 2
    area_single_spot = math.pi * spot_radius_pt ** 2
    n_spots = int((coverage * area_total) / area_single_spot * density)
    c.setFillColor(colors.black)
    for _ in range(n_spots):
        angle = random.uniform(0, 2 * math.pi)
        r = radius_pt * math.sqrt(random.uniform(0, 1))
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        c.circle(x, y, spot_radius_pt, stroke=0, fill=1)

def add_diffuse_preview(draw, cx, cy, radius_px, coverage, spot_size_px, density):
    """Preview for diffuse pattern"""
    if coverage <= 0:
        return
    spot_radius_px = max(1.0, spot_size_px / 2.0)
    area_total = math.pi * radius_px ** 2
    area_single_spot = math.pi * spot_radius_px ** 2
    n_spots = int((coverage * area_total) / area_single_spot * density)
    for _ in range(n_spots):
        angle = random.uniform(0, 2 * math.pi)
        r = radius_px * math.sqrt(random.uniform(0, 1))
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        draw.ellipse((x - spot_radius_px, y - spot_radius_px,
                     x + spot_radius_px, y + spot_radius_px), fill=0)

# ========== PATCHY PATTERN ==========
def add_patchy(c, cx, cy, radius_pt, coverage, patch_size_mm, dispersion):
    """Add larger irregular patches (patchy fibrosis)"""
    if coverage <= 0:
        return
    patch_radius_pt = (patch_size_mm / 2.0) * mm
    area_total = math.pi * radius_pt ** 2
    area_single_patch = math.pi * patch_radius_pt ** 2
    n_patches = int((coverage * area_total) / area_single_patch)
    c.setFillColor(colors.black)
    for _ in range(n_patches):
        angle = random.uniform(0, 2 * math.pi)
        r_factor = random.uniform(0, 1) ** (1.0 / dispersion)
        r = radius_pt * r_factor
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        irregularity = random.uniform(0.8, 1.2)
        c.ellipse(x - patch_radius_pt * irregularity, y - patch_radius_pt,
                 x + patch_radius_pt * irregularity, y + patch_radius_pt,
                 stroke=0, fill=1)

def add_patchy_preview(draw, cx, cy, radius_px, coverage, patch_size_px, dispersion):
    """Preview for patchy pattern"""
    if coverage <= 0:
        return
    patch_radius_px = max(2.0, patch_size_px / 2.0)
    area_total = math.pi * radius_px ** 2
    area_single_patch = math.pi * patch_radius_px ** 2
    n_patches = int((coverage * area_total) / area_single_patch)
    for _ in range(n_patches):
        angle = random.uniform(0, 2 * math.pi)
        r_factor = random.uniform(0, 1) ** (1.0 / dispersion)
        r = radius_px * r_factor
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        irregularity = random.uniform(0.8, 1.2)
        draw.ellipse((x - patch_radius_px * irregularity, y - patch_radius_px,
                     x + patch_radius_px * irregularity, y + patch_radius_px), fill=0)

# ========== COMPACT PATTERN ==========
def add_compact(c, cx, cy, radius_pt, coverage, border_width_mm):
    """Add solid central region (compact fibrosis)"""
    if coverage <= 0:
        return
    scar_radius_pt = radius_pt * math.sqrt(coverage)
    c.setFillColor(colors.black)
    c.circle(cx, cy, scar_radius_pt, stroke=0, fill=1)
    if border_width_mm > 0:
        border_pt = border_width_mm * mm
        c.setFillColor(colors.white)
        c.setStrokeColor(colors.white)
        c.setLineWidth(border_pt)
        c.circle(cx, cy, scar_radius_pt, stroke=1, fill=0)

def add_compact_preview(draw, cx, cy, radius_px, coverage, border_width_px):
    """Preview for compact pattern"""
    if coverage <= 0:
        return
    scar_radius_px = radius_px * math.sqrt(coverage)
    draw.ellipse((cx - scar_radius_px, cy - scar_radius_px,
                 cx + scar_radius_px, cy + scar_radius_px), fill=0)
    if border_width_px > 0:
        border_px = max(1, int(border_width_px))
        draw.ellipse((cx - scar_radius_px, cy - scar_radius_px,
                     cx + scar_radius_px, cy + scar_radius_px),
                    outline=255, width=border_px)

# ========== MAIN GENERATION FUNCTIONS ==========
def render_pattern_image(size_px, pattern_type, coverage, circle_diameter_mm, **kwargs):
    """Render preview image"""
    base = Image.new("L", (size_px, size_px), 0)
    draw_base = ImageDraw.Draw(base)
    cx = cy = size_px / 2.0
    radius_px = size_px * 0.45
    draw_base.ellipse((cx - radius_px, cy - radius_px, cx + radius_px, cy + radius_px), fill=255)
    
    tissue = Image.new("L", (size_px, size_px), 255)
    draw_t = ImageDraw.Draw(tissue)
    
    if pattern_type == "Interstitial":
        stripe_width_mm = kwargs.get("stripe_width_mm", 0.02)
        angle_deg = kwargs.get("angle_deg", 0)
        stripe_width_px = (stripe_width_mm / circle_diameter_mm) * (2 * radius_px)
        add_interstitial_preview(draw_t, cx, cy, radius_px, coverage, stripe_width_px, angle_deg)
    
    elif pattern_type == "Diffuse":
        spot_size_mm = kwargs.get("spot_size_mm", 0.05)
        density = kwargs.get("density", 1.0)
        spot_size_px = (spot_size_mm / circle_diameter_mm) * (2 * radius_px)
        add_diffuse_preview(draw_t, cx, cy, radius_px, coverage, spot_size_px, density)
    
    elif pattern_type == "Patchy":
        patch_size_mm = kwargs.get("patch_size_mm", 0.5)
        dispersion = kwargs.get("dispersion", 1.0)
        patch_size_px = (patch_size_mm / circle_diameter_mm) * (2 * radius_px)
        add_patchy_preview(draw_t, cx, cy, radius_px, coverage, patch_size_px, dispersion)
    
    elif pattern_type == "Compact":
        border_width_mm = kwargs.get("border_width_mm", 0.1)
        border_width_px = (border_width_mm / circle_diameter_mm) * (2 * radius_px)
        add_compact_preview(draw_t, cx, cy, radius_px, coverage, border_width_px)
    
    mask = Image.new("L", (size_px, size_px), 0)
    draw_m = ImageDraw.Draw(mask)
    draw_m.ellipse((cx - radius_px, cy - radius_px, cx + radius_px, cy + radius_px), fill=255)
    base.paste(tissue, (0, 0), mask)
    return base.convert("RGB")

def generate_pattern(filename, pattern_type, coverage, circle_diameter_mm, seed=None, **kwargs):
    """Generate PDF pattern"""
    if seed is not None:
        random.seed(seed)
    
    dummy_size = circle_diameter_mm * mm + 4 * mm
    c = canvas.Canvas(filename, pagesize=(dummy_size, dummy_size))
    page_size, cx, cy, radius_pt = draw_circle_background(c, circle_diameter_mm)
    clip_to_circle(c, cx, cy, radius_pt)
    
    if pattern_type == "Interstitial":
        stripe_width_mm = kwargs.get("stripe_width_mm", 0.02)
        angle_deg = kwargs.get("angle_deg", 0)
        add_interstitial(c, cx, cy, radius_pt, coverage, stripe_width_mm, angle_deg)
    
    elif pattern_type == "Diffuse":
        spot_size_mm = kwargs.get("spot_size_mm", 0.05)
        density = kwargs.get("density", 1.0)
        add_diffuse(c, cx, cy, radius_pt, coverage, spot_size_mm, density)
    
    elif pattern_type == "Patchy":
        patch_size_mm = kwargs.get("patch_size_mm", 0.5)
        dispersion = kwargs.get("dispersion", 1.0)
        add_patchy(c, cx, cy, radius_pt, coverage, patch_size_mm, dispersion)
    
    elif pattern_type == "Compact":
        border_width_mm = kwargs.get("border_width_mm", 0.1)
        add_compact(c, cx, cy, radius_pt, coverage, border_width_mm)
    
    end_clip(c)
    c.showPage()
    c.save()

# ========== GUI ==========
class FibrosisPatternGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("PRIMO Myocardial Fibrosis Pattern Generator")
        self.preview_size = 400
        self.preview_image_tk = None
        self.last_seed = None
        self._build_widgets()
    
    def _build_widgets(self):
        # Variables
        self.var_pattern_type = tk.StringVar(value="Interstitial")
        self.var_mattek_size = tk.StringVar(value="35mm dish (10mm well)")
        self.var_coverage = tk.DoubleVar(value=20.0)
        
        # Interstitial
        self.var_stripe_width = tk.DoubleVar(value=20.0)
        self.var_stripe_angle = tk.DoubleVar(value=0.0)
        
        # Diffuse
        self.var_spot_size = tk.DoubleVar(value=50.0)
        self.var_density = tk.DoubleVar(value=1.0)
        
        # Patchy
        self.var_patch_size = tk.DoubleVar(value=500.0)
        self.var_dispersion = tk.DoubleVar(value=1.0)
        
        # Compact
        self.var_border_width = tk.DoubleVar(value=100.0)
        
        main = ttk.Frame(self.root, padding=10)
        main.grid(row=0, column=0, sticky="nsew")
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        
        controls = ttk.Frame(main)
        controls.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        
        preview_frame = ttk.Frame(main)
        preview_frame.grid(row=0, column=1, sticky="nsew")
        main.columnconfigure(1, weight=1)
        main.rowconfigure(0, weight=1)
        
        row = 0
        
        # Pattern type
        ttk.Label(controls, text="Pattern Type:").grid(row=row, column=0, sticky="w")
        pattern_menu = ttk.Combobox(controls, textvariable=self.var_pattern_type,
                                    values=["Interstitial", "Diffuse", "Patchy", "Compact"],
                                    state="readonly", width=15)
        pattern_menu.grid(row=row, column=1, sticky="ew", pady=2)
        pattern_menu.bind("<<ComboboxSelected>>", self._on_pattern_change)
        row += 1
        
        # MatTek size
        ttk.Label(controls, text="MatTek Well:").grid(row=row, column=0, sticky="w")
        mattek_menu = ttk.Combobox(controls, textvariable=self.var_mattek_size,
                                   values=list(MATTEK_SIZES.keys()),
                                   state="readonly", width=20)
        mattek_menu.grid(row=row, column=1, sticky="ew", pady=2)
        row += 1
        
        # Coverage
        self._add_entry(controls, row, "Coverage (%):", self.var_coverage, "%")
        row += 1
        
        # Pattern-specific parameters frame
        self.params_frame = ttk.LabelFrame(controls, text="Pattern Parameters", padding=5)
        self.params_frame.grid(row=row, column=0, columnspan=2, sticky="ew", pady=10)
        row += 1
        
        # Buttons
        btn_frame = ttk.Frame(controls)
        btn_frame.grid(row=row, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        btn_preview = ttk.Button(btn_frame, text="Update Preview", command=self.on_preview)
        btn_preview.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        btn_generate = ttk.Button(btn_frame, text="Generate PDF", command=self.on_generate)
        btn_generate.grid(row=0, column=1, sticky="ew", padx// filepath: c:\Users\shapi\OneDrive\Desktop\pattern-creator\pattern-creator.py
import math
import random
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from reportlab.pdfgen import canvas
from reportlab.lib.units import mm
from reportlab.lib import colors
from PIL import Image, ImageDraw, ImageTk

# Common MatTek well diameters (mm)
MATTEK_SIZES = {
    "35mm dish (20mm well)": 20.0,
    "35mm dish (14mm well)": 14.0,
    "35mm dish (10mm well)": 10.0,
    "50mm dish (30mm well)": 30.0,
}

def draw_circle_background(c, diameter_mm):
    """Draw black background with white circle"""
    radius_pt = (diameter_mm / 2.0) * mm
    page_size = diameter_mm * mm + 4 * mm
    cx = cy = page_size / 2.0
    c.setFillColor(colors.black)
    c.rect(0, 0, page_size, page_size, stroke=0, fill=1)
    c.setFillColor(colors.white)
    c.circle(cx, cy, radius_pt, stroke=0, fill=1)
    return page_size, cx, cy, radius_pt

def clip_to_circle(c, cx, cy, radius_pt):
    """Clip drawing to circular region"""
    c.saveState()
    p = c.beginPath()
    p.circle(cx, cy, radius_pt)
    c.clipPath(p, stroke=0, fill=0)

def end_clip(c):
    """End clipping"""
    c.restoreState()

# ========== INTERSTITIAL PATTERN ==========
def add_interstitial(c, cx, cy, radius_pt, coverage, stripe_width_mm, angle_deg=0):
    """Add parallel stripes (interstitial fibrosis)"""
    if coverage <= 0:
        return
    stripe_width_pt = stripe_width_mm * mm
    if coverage >= 1:
        gap_pt = 0
    else:
        gap_pt = stripe_width_pt * (1.0 - coverage) / max(coverage, 1e-6)
    diag = radius_pt * 2 * math.sqrt(2)
    total_width = diag + 4 * (stripe_width_pt + gap_pt)
    x0 = cx - total_width / 2.0
    c.saveState()
    c.translate(cx, cy)
    c.rotate(angle_deg)
    c.translate(-cx, -cy)
    c.setFillColor(colors.black)
    x = x0
    while x < x0 + total_width:
        c.rect(x, cy - diag / 2.0, stripe_width_pt, diag, stroke=0, fill=1)
        x += stripe_width_pt + gap_pt
    c.restoreState()

def add_interstitial_preview(draw, cx, cy, radius_px, coverage, stripe_width_px, angle_deg):
    """Preview for interstitial pattern"""
    temp = Image.new("L", draw.im.size, 255)
    dtemp = ImageDraw.Draw(temp)
    stripe_width_px = max(1.0, stripe_width_px)
    if coverage > 0:
        gap_px = stripe_width_px * (1.0 - coverage) / max(coverage, 1e-6)
    else:
        gap_px = 0
    diag = radius_px * 2 * math.sqrt(2)
    total_width = diag + 4 * (stripe_width_px + gap_px)
    x0 = -total_width / 2.0
    angle = math.radians(angle_deg)
    cos_a = math.cos(angle)
    sin_a = math.sin(angle)
    x = x0
    while x < x0 + total_width:
        xr0, xr1 = x, x + stripe_width_px
        y_low, y_high = -diag / 2.0, diag / 2.0
        corners_r = [(xr0, y_low), (xr1, y_low), (xr1, y_high), (xr0, y_high)]
        pts = [(cx + xr * cos_a - yr * sin_a, cy + xr * sin_a + yr * cos_a) for xr, yr in corners_r]
        dtemp.polygon(pts, fill=0)
        x += stripe_width_px + gap_px
    mask = Image.new("L", draw.im.size, 0)
    dmask = ImageDraw.Draw(mask)
    dmask.ellipse((cx-radius_px, cy-radius_px, cx+radius_px, cy+radius_px), fill=255)
    temp.paste(255, mask=Image.eval(mask, lambda v: 255-v))
    draw.bitmap((0, 0), temp)

# ========== DIFFUSE PATTERN ==========
def add_diffuse(c, cx, cy, radius_pt, coverage, spot_size_mm, density):
    """Add randomly distributed small spots (diffuse fibrosis)"""
    if coverage <= 0:
        return
    spot_radius_pt = (spot_size_mm / 2.0) * mm
    area_total = math.pi * radius_pt ** 2
    area_single_spot = math.pi * spot_radius_pt ** 2
    n_spots = int((coverage * area_total) / area_single_spot * density)
    c.setFillColor(colors.black)
    for _ in range(n_spots):
        angle = random.uniform(0, 2 * math.pi)
        r = radius_pt * math.sqrt(random.uniform(0, 1))
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        c.circle(x, y, spot_radius_pt, stroke=0, fill=1)

def add_diffuse_preview(draw, cx, cy, radius_px, coverage, spot_size_px, density):
    """Preview for diffuse pattern"""
    if coverage <= 0:
        return
    spot_radius_px = max(1.0, spot_size_px / 2.0)
    area_total = math.pi * radius_px ** 2
    area_single_spot = math.pi * spot_radius_px ** 2
    n_spots = int((coverage * area_total) / area_single_spot * density)
    for _ in range(n_spots):
        angle = random.uniform(0, 2 * math.pi)
        r = radius_px * math.sqrt(random.uniform(0, 1))
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        draw.ellipse((x - spot_radius_px, y - spot_radius_px,
                     x + spot_radius_px, y + spot_radius_px), fill=0)

# ========== PATCHY PATTERN ==========
def add_patchy(c, cx, cy, radius_pt, coverage, patch_size_mm, dispersion):
    """Add larger irregular patches (patchy fibrosis)"""
    if coverage <= 0:
        return
    patch_radius_pt = (patch_size_mm / 2.0) * mm
    area_total = math.pi * radius_pt ** 2
    area_single_patch = math.pi * patch_radius_pt ** 2
    n_patches = int((coverage * area_total) / area_single_patch)
    c.setFillColor(colors.black)
    for _ in range(n_patches):
        angle = random.uniform(0, 2 * math.pi)
        r_factor = random.uniform(0, 1) ** (1.0 / dispersion)
        r = radius_pt * r_factor
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        irregularity = random.uniform(0.8, 1.2)
        c.ellipse(x - patch_radius_pt * irregularity, y - patch_radius_pt,
                 x + patch_radius_pt * irregularity, y + patch_radius_pt,
                 stroke=0, fill=1)

def add_patchy_preview(draw, cx, cy, radius_px, coverage, patch_size_px, dispersion):
    """Preview for patchy pattern"""
    if coverage <= 0:
        return
    patch_radius_px = max(2.0, patch_size_px / 2.0)
    area_total = math.pi * radius_px ** 2
    area_single_patch = math.pi * patch_radius_px ** 2
    n_patches = int((coverage * area_total) / area_single_patch)
    for _ in range(n_patches):
        angle = random.uniform(0, 2 * math.pi)
        r_factor = random.uniform(0, 1) ** (1.0 / dispersion)
        r = radius_px * r_factor
        x = cx + r * math.cos(angle)
        y = cy + r * math.sin(angle)
        irregularity = random.uniform(0.8, 1.2)
        draw.ellipse((x - patch_radius_px * irregularity, y - patch_radius_px,
                     x + patch_radius_px * irregularity, y + patch_radius_px), fill=0)

# ========== COMPACT PATTERN ==========
def add_compact(c, cx, cy, radius_pt, coverage, border_width_mm):
    """Add solid central region (compact fibrosis)"""
    if coverage <= 0:
        return
    scar_radius_pt = radius_pt * math.sqrt(coverage)
    c.setFillColor(colors.black)
    c.circle(cx, cy, scar_radius_pt, stroke=0, fill=1)
    if border_width_mm > 0:
        border_pt = border_width_mm * mm
        c.setFillColor(colors.white)
        c.setStrokeColor(colors.white)
        c.setLineWidth(border_pt)
        c.circle(cx, cy, scar_radius_pt, stroke=1, fill=0)

def add_compact_preview(draw, cx, cy, radius_px, coverage, border_width_px):
    """Preview for compact pattern"""
    if coverage <= 0:
        return
    scar_radius_px = radius_px * math.sqrt(coverage)
    draw.ellipse((cx - scar_radius_px, cy - scar_radius_px,
                 cx + scar_radius_px, cy + scar_radius_px), fill=0)
    if border_width_px > 0:
        border_px = max(1, int(border_width_px))
        draw.ellipse((cx - scar_radius_px, cy - scar_radius_px,
                     cx + scar_radius_px, cy + scar_radius_px),
                    outline=255, width=border_px)

# ========== MAIN GENERATION FUNCTIONS ==========
def render_pattern_image(size_px, pattern_type, coverage, circle_diameter_mm, **kwargs):
    """Render preview image"""
    base = Image.new("L", (size_px, size_px), 0)
    draw_base = ImageDraw.Draw(base)
    cx = cy = size_px / 2.0
    radius_px = size_px * 0.45
    draw_base.ellipse((cx - radius_px, cy - radius_px, cx + radius_px, cy + radius_px), fill=255)
    
    tissue = Image.new("L", (size_px, size_px), 255)
    draw_t = ImageDraw.Draw(tissue)
    
    if pattern_type == "Interstitial":
        stripe_width_mm = kwargs.get("stripe_width_mm", 0.02)
        angle_deg = kwargs.get("angle_deg", 0)
        stripe_width_px = (stripe_width_mm / circle_diameter_mm) * (2 * radius_px)
        add_interstitial_preview(draw_t, cx, cy, radius_px, coverage, stripe_width_px, angle_deg)
    
    elif pattern_type == "Diffuse":
        spot_size_mm = kwargs.get("spot_size_mm", 0.05)
        density = kwargs.get("density", 1.0)
        spot_size_px = (spot_size_mm / circle_diameter_mm) * (2 * radius_px)
        add_diffuse_preview(draw_t, cx, cy, radius_px, coverage, spot_size_px, density)
    
    elif pattern_type == "Patchy":
        patch_size_mm = kwargs.get("patch_size_mm", 0.5)
        dispersion = kwargs.get("dispersion", 1.0)
        patch_size_px = (patch_size_mm / circle_diameter_mm) * (2 * radius_px)
        add_patchy_preview(draw_t, cx, cy, radius_px, coverage, patch_size_px, dispersion)
    
    elif pattern_type == "Compact":
        border_width_mm = kwargs.get("border_width_mm", 0.1)
        border_width_px = (border_width_mm / circle_diameter_mm) * (2 * radius_px)
        add_compact_preview(draw_t, cx, cy, radius_px, coverage, border_width_px)
    
    mask = Image.new("L", (size_px, size_px), 0)
    draw_m = ImageDraw.Draw(mask)
    draw_m.ellipse((cx - radius_px, cy - radius_px, cx + radius_px, cy + radius_px), fill=255)
    base.paste(tissue, (0, 0), mask)
    return base.convert("RGB")

def generate_pattern(filename, pattern_type, coverage, circle_diameter_mm, seed=None, **kwargs):
    """Generate PDF pattern"""
    if seed is not None:
        random.seed(seed)
    
    dummy_size = circle_diameter_mm * mm + 4 * mm
    c = canvas.Canvas(filename, pagesize=(dummy_size, dummy_size))
    page_size, cx, cy, radius_pt = draw_circle_background(c, circle_diameter_mm)
    clip_to_circle(c, cx, cy, radius_pt)
    
    if pattern_type == "Interstitial":
        stripe_width_mm = kwargs.get("stripe_width_mm", 0.02)
        angle_deg = kwargs.get("angle_deg", 0)
        add_interstitial(c, cx, cy, radius_pt, coverage, stripe_width_mm, angle_deg)
    
    elif pattern_type == "Diffuse":
        spot_size_mm = kwargs.get("spot_size_mm", 0.05)
        density = kwargs.get("density", 1.0)
        add_diffuse(c, cx, cy, radius_pt, coverage, spot_size_mm, density)
    
    elif pattern_type == "Patchy":
        patch_size_mm = kwargs.get("patch_size_mm", 0.5)
        dispersion = kwargs.get("dispersion", 1.0)
        add_patchy(c, cx, cy, radius_pt, coverage, patch_size_mm, dispersion)
    
    elif pattern_type == "Compact":
        border_width_mm = kwargs.get("border_width_mm", 0.1)
        add_compact(c, cx, cy, radius_pt, coverage, border_width_mm)
    
    end_clip(c)
    c.showPage()
    c.save()

# ========== GUI ==========
class FibrosisPatternGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("PRIMO Myocardial Fibrosis Pattern Generator")
        self.preview_size = 400
        self.preview_image_tk = None
        self.last_seed = None
        self._build_widgets()
    
    def _build_widgets(self):
        # Variables
        self.var_pattern_type = tk.StringVar(value="Interstitial")
        self.var_mattek_size = tk.StringVar(value="35mm dish (10mm well)")
        self.var_coverage = tk.DoubleVar(value=20.0)
        
        # Interstitial
        self.var_stripe_width = tk.DoubleVar(value=20.0)
        self.var_stripe_angle = tk.DoubleVar(value=0.0)
        
        # Diffuse
        self.var_spot_size = tk.DoubleVar(value=50.0)
        self.var_density = tk.DoubleVar(value=1.0)
        
        # Patchy
        self.var_patch_size = tk.DoubleVar(value=500.0)
        self.var_dispersion = tk.DoubleVar(value=1.0)
        
        # Compact
        self.var_border_width = tk.DoubleVar(value=100.0)
        
        main = ttk.Frame(self.root, padding=10)
        main.grid(row=0, column=0, sticky="nsew")
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        
        controls = ttk.Frame(main)
        controls.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        
        preview_frame = ttk.Frame(main)
        preview_frame.grid(row=0, column=1, sticky="nsew")
        main.columnconfigure(1, weight=1)
        main.rowconfigure(0, weight=1)
        
        row = 0
        
        # Pattern type
        ttk.Label(controls, text="Pattern Type:").grid(row=row, column=0, sticky="w")
        pattern_menu = ttk.Combobox(controls, textvariable=self.var_pattern_type,
                                    values=["Interstitial", "Diffuse", "Patchy", "Compact"],
                                    state="readonly", width=15)
        pattern_menu.grid(row=row, column=1, sticky="ew", pady=2)
        pattern_menu.bind("<<ComboboxSelected>>", self._on_pattern_change)
        row += 1
        
        # MatTek size
        ttk.Label(controls, text="MatTek Well:").grid(row=row, column=0, sticky="w")
        mattek_menu = ttk.Combobox(controls, textvariable=self.var_mattek_size,
                                   values=list(MATTEK_SIZES.keys()),
                                   state="readonly", width=20)
        mattek_menu.grid(row=row, column=1, sticky="ew", pady=2)
        row += 1
        
        # Coverage
        self._add_entry(controls, row, "Coverage (%):", self.var_coverage, "%")
        row += 1
        
        # Pattern-specific parameters frame
        self.params_frame = ttk.LabelFrame(controls, text="Pattern Parameters", padding=5)
        self.params_frame.grid(row=row, column=0, columnspan=2, sticky="ew", pady=10)
        row += 1
        
        # Buttons
        btn_frame = ttk.Frame(controls)
        btn_frame.grid(row=row, column=0, columnspan=2, sticky="ew", pady=(10, 0))
        btn_preview = ttk.Button(btn_frame, text="Update Preview", command=self.on_preview)
        btn_preview.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        btn_generate = ttk.Button(btn_frame, text="Generate PDF", command=self.on_generate)
        btn_generate.grid(row=0, column=1, sticky="ew", padx